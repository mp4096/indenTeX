mod parsers;
mod parsing_types;
pub mod preprocessing;
mod utils;

const LINESEP: &str = "\n";
const LATEX_TO_INDENTEX_FACTOR: f64 = 1.5;
const DO_NOT_EDIT_NOTICE: &str =
    "\
     % ============================================================== %\n\
     %                                                                %\n\
     % THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. %\n\
     %                                                                %\n\
     % ============================================================== %\n";

pub struct TranspileOptions {
    pub flatten_output: bool,
    pub prepend_do_not_edit_notice: bool,
}

pub fn transpile(mut lines: Vec<String>, options: &TranspileOptions) -> String {
    use crate::parsers::process_line;
    use crate::parsing_types::Environment;
    use crate::parsing_types::Hashline::{OpenEnv, PlainLine};

    // The number of environments is not known beforehand
    let mut env_stack: Vec<Environment> = Vec::new();

    // Input size is the sum of all line lengths plus the number of lines (for lineseps)
    let input_size = lines.iter().fold(0, |sum, l| sum + l.len()) + lines.len();
    // We do not know how much larger the transpiled LaTeX file will be, but we can guess...
    let indentex_size = (LATEX_TO_INDENTEX_FACTOR * (input_size as f64)).round() as usize;
    let mut transpiled = String::with_capacity(indentex_size);

    let adjusted_indents = crate::utils::scan_indents(lines.as_ref());

    if options.prepend_do_not_edit_notice {
        transpiled.push_str(DO_NOT_EDIT_NOTICE);
    }

    for (line_num, line) in lines.drain(..).enumerate() {
        let list_like_active = match env_stack.last() {
            None => false, // No environment is active at all
            Some(d) => d.is_list_like(),
        };

        let tl = match process_line(line, list_like_active) {
            PlainLine(l) => l,
            OpenEnv(e) => {
                let tag_begin = e.latex_begin();
                env_stack.push(e);
                tag_begin
            }
        };
        if options.flatten_output {
            transpiled.push_str(tl.trim_start());
        } else {
            transpiled.push_str(&tl);
        }
        transpiled.push_str(LINESEP);

        // Check if we are in an environment and close as many as needed
        while match env_stack.last() {
            None => false,
            Some(d) => d.indent_depth() >= adjusted_indents[line_num + 1],
        } {
            // `unwrap()` is safe here since we have already checked if the stack is empty
            let tag_end = env_stack.pop().unwrap().latex_end();
            if options.flatten_output {
                transpiled.push_str(tag_end.trim_start());
            } else {
                transpiled.push_str(&tag_end);
            }
            transpiled.push_str(LINESEP);
        }
    }

    transpiled
}

// LCOV_EXCL_START
#[cfg(test)]
mod tests {
    #[cfg(test)]
    mod transpilation_spec {
        use super::super::{transpile, TranspileOptions};

        #[test]
        fn vanilla_latex_is_not_modified() {
            let input = (vec![
                r"\newcommand{\foo}[1]{foo #1}",
                r"  \begin{equation}1+1\end{equation}",
                r" $ 1 + \frac{1}{2}$",
            ])
            .into_iter()
            .map(|s| s.to_string())
            .collect();

            let expected = "\
                            \\newcommand{\\foo}[1]{foo #1}\
                            \n  \\begin{equation}1+1\\end{equation}\
                            \n $ 1 + \\frac{1}{2}$\n";
            let to = TranspileOptions {
                flatten_output: false,
                prepend_do_not_edit_notice: false,
            };
            assert_eq!(&transpile(input, &to), expected);
        }

        #[test]
        fn single_line_commands() {
            let input = (vec!["# foo: bar % qux", "  # foo[opts]: bar"])
                .into_iter()
                .map(|s| s.to_string())
                .collect();

            let expected = "\\foo{bar} % qux\n  \\foo[opts]{bar}\n";
            let to = TranspileOptions {
                flatten_output: false,
                prepend_do_not_edit_notice: false,
            };
            assert_eq!(&transpile(input, &to), expected);
        }

        #[test]
        fn open_and_close_envs_correctly() {
            let input = (vec!["# foo:", "  bar"])
                .into_iter()
                .map(|s| s.to_string())
                .collect();

            let expected = "\\begin{foo}\n  bar\n\\end{foo}\n";
            let to = TranspileOptions {
                flatten_output: false,
                prepend_do_not_edit_notice: false,
            };
            assert_eq!(&transpile(input, &to), expected);
        }

        #[test]
        fn open_and_close_envs_correctly_if_empty_body() {
            let input = (vec!["# foo:", "  # bar:"])
                .into_iter()
                .map(|s| s.to_string())
                .collect();

            let expected = "\\begin{foo}\n  \\begin{bar}\n  \\end{bar}\n\\end{foo}\n";
            let to = TranspileOptions {
                flatten_output: false,
                prepend_do_not_edit_notice: false,
            };
            assert_eq!(&transpile(input, &to), expected);
        }

        #[test]
        fn open_and_close_envs_correctly_with_flattened_output() {
            let input = (vec!["# foo:", "  # bar:"])
                .into_iter()
                .map(|s| s.to_string())
                .collect();

            let expected = "\\begin{foo}\n\\begin{bar}\n\\end{bar}\n\\end{foo}\n";
            let to = TranspileOptions {
                flatten_output: true,
                prepend_do_not_edit_notice: false,
            };
            assert_eq!(&transpile(input, &to), expected);
        }

        #[test]
        fn do_not_edit_notice() {
            let to = TranspileOptions {
                flatten_output: false,
                prepend_do_not_edit_notice: true,
            };
            assert_eq!(
                &transpile(vec!["".to_string()], &to),
                &format!("{}\n", super::super::DO_NOT_EDIT_NOTICE)
            );
        }
    }
}
// LCOV_EXCL_STOP
